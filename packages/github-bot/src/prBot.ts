/**
 * JAVARI ENGINEERING OS - GITHUB PR BOT
 * Creates pull requests from builder output
 * 
 * This closes the loop: Audit â†’ WorkItem â†’ Builder â†’ PR â†’ Review â†’ Merge
 */

import crypto from 'node:crypto';
import { supabaseAdmin } from '@javari/shared';

// ==========================================================================
// TYPES
// ==========================================================================

interface PatchBundle {
  workItemId: string;
  changes: Record<string, string>;
  summaryMd: string;
  verificationCommands: string[];
}

interface PRResult {
  created: boolean;
  prUrl?: string;
  branch?: string;
  error?: string;
}

// ==========================================================================
// GITHUB API HELPER
// ==========================================================================

async function gh<T>(path: string, opts: { method?: string; body?: unknown } = {}): Promise<T> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) throw new Error('Missing GITHUB_TOKEN');
  
  const res = await fetch(`https://api.github.com${path}`, {
    method: opts.method ?? 'GET',
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: 'application/vnd.github+json',
      'Content-Type': 'application/json',
      'User-Agent': 'javari-engineering-os',
    },
    body: opts.body ? JSON.stringify(opts.body) : undefined,
  });
  
  const text = await res.text();
  if (!res.ok) {
    throw new Error(`GitHub API ${res.status} ${path}: ${text}`);
  }
  
  return JSON.parse(text) as T;
}

// ==========================================================================
// PR CREATION
// ==========================================================================

export async function createPRFromPatchBundle(
  owner: string,
  repo: string,
  baseBranch: string,
  bundle: PatchBundle
): Promise<PRResult> {
  const supa = supabaseAdmin();
  const branchName = `javari/fix-${bundle.workItemId.slice(0, 8)}-${crypto.randomUUID().slice(0, 6)}`;
  
  try {
    // Get base branch ref
    const baseRef = await gh<{ object: { sha: string } }>(
      `/repos/${owner}/${repo}/git/ref/heads/${baseBranch}`
    );
    const baseSha = baseRef.object.sha;
    
    // Create new branch
    await gh(`/repos/${owner}/${repo}/git/refs`, {
      method: 'POST',
      body: { ref: `refs/heads/${branchName}`, sha: baseSha },
    });
    
    // Get base tree
    const baseCommit = await gh<{ tree: { sha: string } }>(
      `/repos/${owner}/${repo}/git/commits/${baseSha}`
    );
    const baseTreeSha = baseCommit.tree.sha;
    
    // Create blobs for each changed file
    const treeItems: Array<{ path: string; mode: string; type: string; sha: string }> = [];
    
    for (const [filePath, content] of Object.entries(bundle.changes)) {
      const blob = await gh<{ sha: string }>(`/repos/${owner}/${repo}/git/blobs`, {
        method: 'POST',
        body: { content, encoding: 'utf-8' },
      });
      
      treeItems.push({
        path: filePath,
        mode: '100644',
        type: 'blob',
        sha: blob.sha,
      });
    }
    
    // Create new tree
    const newTree = await gh<{ sha: string }>(`/repos/${owner}/${repo}/git/trees`, {
      method: 'POST',
      body: { base_tree: baseTreeSha, tree: treeItems },
    });
    
    // Create commit
    const commit = await gh<{ sha: string }>(`/repos/${owner}/${repo}/git/commits`, {
      method: 'POST',
      body: {
        message: `fix: ${bundle.summaryMd.slice(0, 72)}`,
        tree: newTree.sha,
        parents: [baseSha],
      },
    });
    
    // Update branch ref
    await gh(`/repos/${owner}/${repo}/git/refs/heads/${branchName}`, {
      method: 'PATCH',
      body: { sha: commit.sha, force: true },
    });
    
    // Fetch work item for PR body
    const { data: workItem } = await supa
      .from('work_items')
      .select('title, description, severity, acceptance_criteria, verification_plan')
      .eq('id', bundle.workItemId)
      .single();
    
    // Create PR
    const prBody = `## ðŸ¤– Javari Automated Fix

### Work Item
**Title:** ${workItem?.title || 'Unknown'}
**Severity:** ${workItem?.severity || 'Unknown'}

### Summary
${bundle.summaryMd}

### Acceptance Criteria
${(workItem?.acceptance_criteria || []).map((c: string) => `- [ ] ${c}`).join('\n')}

### Verification
\`\`\`bash
${bundle.verificationCommands.join('\n') || 'pnpm test'}
\`\`\`

---
*Generated by Javari Engineering OS*`;
    
    const pr = await gh<{ html_url: string; number: number }>(
      `/repos/${owner}/${repo}/pulls`,
      {
        method: 'POST',
        body: {
          title: `fix: ${workItem?.title || bundle.summaryMd.slice(0, 60)}`,
          head: branchName,
          base: baseBranch,
          body: prBody,
        },
      }
    );
    
    // Update work item status and store PR artifact
    await supa.from('work_items').update({ status: 'PR_OPENED' }).eq('id', bundle.workItemId);
    
    await supa.from('work_artifacts').insert([{
      work_item_id: bundle.workItemId,
      artifact_type: 'pr',
      url: pr.html_url,
      metadata: {
        branch: branchName,
        prNumber: pr.number,
        commit: commit.sha,
        repo: `${owner}/${repo}`,
      },
    }]);
    
    console.log(`[GitHub] PR created: ${pr.html_url}`);
    
    return {
      created: true,
      prUrl: pr.html_url,
      branch: branchName,
    };
    
  } catch (err) {
    const errorMsg = err instanceof Error ? err.message : String(err);
    
    await supa.from('work_items').update({
      status: 'FAILED',
      last_error: `PR creation failed: ${errorMsg}`,
    }).eq('id', bundle.workItemId);
    
    return {
      created: false,
      error: errorMsg,
    };
  }
}

// ==========================================================================
// CREATE PR FROM WORK ITEM
// ==========================================================================

export async function createPRForWorkItem(workItemId: string): Promise<PRResult> {
  const supa = supabaseAdmin();
  
  // Get the patch bundle artifact
  const { data: artifact } = await supa
    .from('work_artifacts')
    .select('metadata')
    .eq('work_item_id', workItemId)
    .eq('artifact_type', 'patch_bundle')
    .order('created_at', { ascending: false })
    .limit(1)
    .single();
  
  if (!artifact?.metadata) {
    return { created: false, error: 'No patch bundle found' };
  }
  
  const bundle = artifact.metadata as PatchBundle;
  bundle.workItemId = workItemId;
  
  // Get repo from work item or use default
  const { data: workItem } = await supa
    .from('work_items')
    .select('repo')
    .eq('id', workItemId)
    .single();
  
  const repoPath = workItem?.repo || process.env.DEFAULT_REPO || 'CR-AudioViz-AI/javari-ai';
  const [owner, repo] = repoPath.split('/');
  const baseBranch = process.env.DEFAULT_BRANCH || 'main';
  
  return createPRFromPatchBundle(owner, repo, baseBranch, bundle);
}

// ==========================================================================
// EXPORTS
// ==========================================================================

export { PatchBundle, PRResult };
